# Paths

## Files

* [include/graphcore/Path.hh](/include/graphcore/Path.hh)
* [src/graphcore/Path.cpp](/src/graphcore/Path.cpp)
* [tests/PathTest.cpp](/tests/PathTest.cpp)

## Definitions

A path *P* in a graph *G* of length *k* is given by 

* a list of nodes *{ n<sub>i</sub> for i = 1 ... k }*
* a start position on *n<sub>1</sub>*
* an end position on *n<sub>k</sub>*

In order path *P* to be valid in *G*, we require

* all nodes in *P* must be present in *G*,
* for all *i* in *1 ... k - 1*, *G* must have an edge
  *(n<sub>i</sub>, n<sub>i+1</sub>)*,
* the start and end position must be valid given the 
  node sequence lengths of *n<sub>1</sub>* and *n<sub>k</sub>*. 
  
In graph-tools, paths can be created as follows:

```c++
Graph G = makeDeletionGraph("TTT", "AT", "CCCCC");
Path P1(&G, 1, { 0, 1, 2 }, 1));
Path P2(&G, 1, { 0, 2 }, 2));
```

Path objects can be used to determine the sequence generated by
a path:

```c++
assert( P1.seq() == "TTATCC" );
assert( P2.seq() == "TTCCC" );
```

We can also generate human-readable encodings for paths:

```c++
assert( "(0@1)-(1)-(2@1)" == P1.encode() );
assert( "(0@1)-(2@2)" == P2.encode() );
```

Here, the start and end positions are encoded as *nodeId@position*.

Other functions provided by paths include:

* functions to test / quantify a path's overlap with a single node.
* `getDistanceFromPathStart()`: Given node *n<sub>j</sub>* and offset *o*, calculate the distance from the start of the path to position
  *n<sub>j</sub>@o* if *n<sub>j</sub>* is contained in the path.
* `shrink*()` / `extend*()` / `shift*()` / `remove*()`: various modifier functions for shrinking and expanding paths at the ends.

# Path Operations

## Files

* [include/graphcore/PathOperations.hh](/include/graphcore/PathOperations.hh)
* [src/graphcore/PathOperations.cpp](/src/graphcore/PathOperations.cpp)
* [tests/PathOperationsTest.cpp](/tests/PathOperationsTest.cpp)

## Operations

### Path Extension (`extendPath*`)

We provide a set of functions to enumerate the possible paths generated
by extending a given path by a number of bases to the left or right.

Furthermore, paths can also be extended while they uniquely match a given
query sequence (`extendPath*Matching*` functions). This is useful to
produce sets of maximal unique matches of a sequence on a graph from
a seed.

### Sequence Decomposition (`splitSequenceByPath`)

```c++
vector<string> splitSequenceByPath(const Path& path, const string& sequence);
```

This function is useful to map a sequence of the same length of a path onto
that path. It returns a list of sequences that correspond to the substring
of the input sequence mapped onto each node in the path.

### Path Overlap and Merging

We provide various operations to check if the union of two
paths will produce valid paths also (`checkIfPathsAdjacent`,
`checkPathPrefixSuffixOverlap`).

If the union of two paths is a valid path, `mergePaths` can be
used to produce this union path.

The `greedyMerge` and `exhaustiveMerge` function
aim to reduce redundancy in a set of paths by merging paths in a set
if they are compatible in the way described above. Exhaustively
merging paths can take a long time since this function attempts
to merge all possible path prefixes with all possible suffixes,
greedy merging will pick only one prefix / suffix combination.

### Path Intersections

```c++
list<Path> intersectPaths(Path const& p1, Path const& p2);
```

This returns a set of all longest paths that are subpaths
of both p1 and p2.